// Copyright (c) 2017 The Authors of 'JWTS for NODE'
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#!/usr/bin/env node
var fs = require('fs');
var spawn = require('child_process').spawn;
var path = require('path');

var ret = 0;
function runTest(test, cb) {
	var env = {};
	for (var ii in process.env) {
		env[ii] = process.env[ii];
	}
	env.NODE_PATH = __dirname;
	var proc = spawn(
		process.execPath,
		[path.join('test', test)],
		{env: env}
	);
	proc.stdout.setEncoding('utf8');
	proc.stderr.setEncoding('utf8');

	var stdout = '', stderr = '';
	proc.stdout.on('data', function(data) {
		stdout += data;
	});
	proc.stderr.on('data', function(data) {
		stderr += data;
	});
	proc.stdin.end();

	proc.on('exit', function(code) {
		if (stdout !== 'pass\n' || stderr !== '') {
			ret = 1;
			console.error(
				test+ ': *fail*\n'+
				'code: '+ code+ '\n'+
				'stderr: '+ stderr+ '\n'+
				'stdout: '+ stdout
			);
		} else if (code !== 0) {
			ret = 1;
			console.error(test+ ': fail ('+ code+ ')');
		} else {
			console.log(test+ ': '+ 'pass');
		}
		cb();
	});
}

var cb = function() {
	process.exit(ret);
};
fs.readdirSync('./test').reverse().forEach(function(file) {
	cb = new function(cb) {
		return function(err) {
			if (err) return cb(err);
			runTest(file, cb);
		};
	}(cb);
});
cb();
