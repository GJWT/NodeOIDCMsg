// Copyright (c) 2017 The Authors of 'JWTS for NODE'
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
var dateFormat = require('dateformat');
var join = require('path').join;
var readFileSync = require('fs').readFileSync;
var semverValid = require('semver').valid;
var through = require('through2');
var util = require('./lib/util');
var _ = require('lodash');

function conventionalChangelogWriter(context, options) {
  var savedKeyCommit;
  var commits = [];
  var firstRelease = true;
  var neverGenerated = true;

  context = _.extend({
    commit: 'commits',
    issue: 'issues',
    date: dateFormat(new Date(), 'yyyy-mm-dd', true)
  }, context);

  if (!_.isBoolean(context.linkReferences) && (context.repository || context.repoUrl) && context.commit && context.issue) {
    context.linkReferences = true;
  }

  options = _.assign({
    groupBy: 'type',
    commitsSort: 'header',
    noteGroupsSort: 'title',
    notesSort: 'text',
    generateOn: function(commit) {
      return semverValid(commit.version);
    },
    finalizeContext: function(context) {
      return context;
    },
    debug: function() {},
    reverse: false,
    includeDetails: false,
    ignoreReverted: true,
    doFlush: true,
    mainTemplate: readFileSync(join(__dirname, 'templates/template.hbs'), 'utf-8'),
    headerPartial: readFileSync(join(__dirname, 'templates/header.hbs'), 'utf-8'),
    commitPartial: readFileSync(join(__dirname, 'templates/commit.hbs'), 'utf-8'),
    footerPartial: readFileSync(join(__dirname, 'templates/footer.hbs'), 'utf-8')
  }, options);

  if (!_.isFunction(options.transform) && _.isObject(options.transform) || _.isUndefined(options.transform)) {
    options.transform = _.assign({
      hash: function(hash) {
        if (_.isString(hash)) {
          return hash.substring(0, 7);
        }
      },
      header: function(header) {
        return header.substring(0, 100);
      },
      committerDate: function(date) {
        if (!date) {
          return;
        }

        return dateFormat(date, 'yyyy-mm-dd', true);
      }
    }, options.transform);
  }

  var generateOn = options.generateOn;
  if (_.isString(generateOn)) {
    generateOn = function(commit) {
      return !_.isUndefined(commit[options.generateOn]);
    };
  } else if (!_.isFunction(generateOn)) {
    generateOn = function() {
      return false;
    };
  }

  options.commitGroupsSort = util.functionify(options.commitGroupsSort);
  options.commitsSort = util.functionify(options.commitsSort);
  options.noteGroupsSort = util.functionify(options.noteGroupsSort);
  options.notesSort = util.functionify(options.notesSort);

  return through.obj(function(chunk, enc, cb) {
    try {
      var result;
      var commit = util.processCommit(chunk, options.transform, context);
      var keyCommit = commit || chunk;

      // previous blocks of logs
      if (options.reverse) {
        if (commit) {
          commits.push(commit);
        }

        if (generateOn(keyCommit, commits, context, options)) {
          neverGenerated = false;
          result = util.generate(options, commits, context, keyCommit);
          if (options.includeDetails) {
            this.push({
              log: result,
              keyCommit: keyCommit
            });
          } else {
            this.push(result);
          }

          commits = [];
        }
      } else {
        if (generateOn(keyCommit, commits, context, options)) {
          neverGenerated = false;
          result = util.generate(options, commits, context, savedKeyCommit);

          if (!firstRelease || options.doFlush) {
            if (options.includeDetails) {
              this.push({
                log: result,
                keyCommit: savedKeyCommit
              });
            } else {
              this.push(result);
            }
          }

          firstRelease = false;
          commits = [];
          savedKeyCommit = keyCommit;
        }

        if (commit) {
          commits.push(commit);
        }
      }

      cb();
    } catch (err) {
      cb(err);
    }
  }, function(cb) {
    if (!options.doFlush && (options.reverse || neverGenerated)) {
      cb(null);
      return;
    }

    try {
      var result = util.generate(options, commits, context, savedKeyCommit);

      if (options.includeDetails) {
        this.push({
          log: result,
          keyCommit: savedKeyCommit
        });
      } else {
        this.push(result);
      }

      cb();
    } catch (err) {
      cb(err);
    }
  });
}

module.exports = conventionalChangelogWriter;
