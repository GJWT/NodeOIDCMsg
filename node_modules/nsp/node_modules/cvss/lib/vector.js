// Copyright (c) 2017 The Authors of 'JWTS for NODE'
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var keys = require('./keys');
var metrics = require('./metrics')

var cvssPrefix = /^CVSS:3\.0/;

function normalize(vector) {
  var payload = {};
  var key, value;
  for (key in vector) {
    if (!metrics.toScore[key]) continue;
    value = vector[key];
    payload[key] = (value in metrics.toScore[key]) ? value : metrics.defaults[key];
  }
  return payload;
}
exports.normalize = normalize;

function parse(input) {

  var parsed = {};
  input.split('/').slice(1).forEach(function (section) {
    if (!section) return;
    var parts = section.split(':');
    parsed[parts[0]] = parts[1];
  });

  return exports.normalize(parsed);
}
exports.parse = parse;

function toString() {
  var key, val;
  var string = '';

  for (key in this) {
    val = this[key];
    if (key in metrics.toScore && typeof val === 'string') {
      string += '/' + key + ':' + val;
    }
  }
  return string ? ('CVSS:3.0' + string) : string;
}
exports.toString = toString;

function validate(input) {
  var type = typeof input;
  var err, vector;
  if (type === 'object' && input !== null) {
    vector = exports.normalize(input);
  } else if (type !== 'string') {
    err = new TypeError('Vector must be an object or string but was a(n) ' + type + ' instead.');
  } else if (!input.match(cvssPrefix)) {
    err = Error('Invalid vector string: CVSS3 version prefix not found.');
  } else {
    vector = exports.parse(input);
  }

  if (vector) {
    keys.base.every(function (key) {
      if (!vector[key]) {
        err = new Error('Invalid CVSS3 vector: missing required metric (' + key + ')');
        return false;
      }
      return true;
    });
  }

  var hasTemporal, hasEnvironmental;
  if (!err) {
    hasTemporal = keys.temporal.some(function (key) {
      return key in vector;
    });
    hasEnvironmental = keys.environmental.some(function (key) {
      return key in vector;
    });
  }

  if (vector) {
    vector.toString = exports.toString;
  }

  return {
    vector: vector,
    type: type,
    error: err,
    hasTemporal: hasTemporal,
    hasEnvironmental: hasEnvironmental
  };
};
exports.validate = validate;
