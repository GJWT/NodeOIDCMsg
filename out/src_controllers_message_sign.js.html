<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: src/controllers/message/sign.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: src/controllers/message/sign.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var timespan = require('./lib/timespan');
var xtend = require('xtend');
var jws = require('../messageTypes/jwt/lib/jws');
var includes = require('lodash.includes');
var isBoolean = require('lodash.isboolean');
var isInteger = require('lodash.isinteger');
var isNumber = require('lodash.isnumber');
var isPlainObject = require('lodash.isplainobject');
var isString = require('lodash.isstring');
var once = require('lodash.once');

var messageSigner = MessageSigner.prototype;

/**
 * @fileoverview Handles the common signing functionality for all message protocols
 */

/**
 * MessageSigner
 * @class
 * @constructor
 */
function MessageSigner(){
};

messageSigner.signOptionsSchema = {
  expiresIn: { isValid: function(value) { return isInteger(value) || isString(value); }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
  notBefore: { isValid: function(value) { return isInteger(value) || isString(value); }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
  audience: { isValid: function(value) { return isString(value) || Array.isArray(value); }, message: '"audience" must be a string or array' },
  algorithm: { isValid: includes.bind(null, ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512', 'HS256', 'HS384', 'HS512', 'none']), message: '"algorithm" must be a valid string enum value' },
  header: { isValid: isPlainObject, message: '"header" must be an object' },
  encoding: { isValid: isString, message: '"encoding" must be a string' },
  issuer: { isValid: isString, message: '"issuer" must be a string' },
  subject: { isValid: isString, message: '"subject" must be a string' },
  jwtid: { isValid: isString, message: '"jwtid" must be a string' },
  noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
  keyid: { isValid: isString, message: '"keyid" must be a string' },
  baseEncoding: { isValid: isString, message: '"baseEncoding" must be a string' },
};

messageSigner.registeredClaimsSchema = {
  iat: { isValid: isNumber, message: '"iat" should be a number of seconds' },
  exp: { isValid: isNumber, message: '"exp" should be a number of seconds' },
  nbf: { isValid: isNumber, message: '"nbf" should be a number of seconds' },
  aud: { isValid: function(value) { return isString(value) || Array.isArray(value); }, message: '"audience" must be a string or array' },
  sub: { isValid: isString, message: '"subject" must be a string' },
  jti: { isValid: isString, message: '"jwtid" must be a string' },
};

/** 
 * Check if the input format type matches the schema. 
 * @memberof MessageSigner
 * @param schema
 * @param allowUnknown
 * @param object
 * @param parameterName
 * */
messageSigner.validate = function(schema, allowUnknown, object, parameterName) {
  if (!isPlainObject(object)) {
    throw new Error('Expected "' + parameterName + '" to be a plain object.');
  }
  Object.keys(object)
    .forEach(function(key) {
      var validator = schema[key];
      if (!validator) {
        if (!allowUnknown) {
          throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
        }
        return;
      }
      if (!validator.isValid(object[key])) {
        throw new Error(validator.message);
      }
    });
}

/** 
 * Checks format type of other options 
 * @param {dictionary} options
 * @memberof MessageSigner
 */
messageSigner.validateOptions = function(options) {
  return this.validate(this.signOptionsSchema, false, options, 'options');
}

/** 
 * Checks format type of payload values
 * @param {dictionary} payload
 * @memberof MessageSigner
 */
messageSigner.validatePayload = function(payload) {
  return this.validate(this.registeredClaimsSchema, true, payload, 'payload');
}

/** 
 * Signs message and checks for valid input.
 * 
 * @param {Token} tokenProfile - Contains the token properties, required, optional and verification claims.
 * @param {string} secretOrPublicKey - String or buffer containing either the secret for HMAC algorithms, or the PEM encoded public key for RSA and ECDSA.
 * @param {dictionary} options - Consists of other inputs that are not part of the payload, for ex : 'algorithm'.
 * @param {function} callback - Called with the decoded payload if the signature is valid and optional expiration, audience, or issuer are valid. If not, it 
    will be called with the error. When supplied, the function acts asynchronously.
 * @returns {dictionary} - Contains the header, payload and options info.
 * @throws JsonWebToken error if options does not match expected claims.
 * @memberof MessageSigner
 */
messageSigner.sign = function (tokenProfile, secretOrPrivateKey, options, callback) {
  var payload = Object.assign({}, tokenProfile.getRequiredClaims(), tokenProfile.getOptionalClaims());
  
  // Init options
  options = this.initOptions(options);

  if (options)
  var isObjectPayload = typeof payload === 'object' &amp;&amp;
                        !Buffer.isBuffer(payload);
  
  // Init header
  var header = xtend({
    alg: options.algorithm || 'HS256',
    typ: isObjectPayload ? 'JWT' : undefined,
    kid: options.keyid
  }, options.header);

  function failure(err) {
    if (callback) {
      return callback(err);
    }
    throw err;
  }

  /** Check for undefined payload or invalid options */ 
  if (typeof payload === 'undefined') {
    return failure(new Error('payload is required'));
  } else if (isObjectPayload) {
    try {
      this.validatePayload(payload);
    }
    catch (error) {
      return failure(error);
    }
    payload = xtend(payload);
  } else {
    var invalidOptions = optionsForObjects.filter(function (opt) {
      return typeof options[opt] !== 'undefined';
    });

    if (invalidOptions.length > 0) {
      return failure(new Error('invalid ' + invalidOptions.join(',') + ' option for ' + (typeof payload ) + ' payload'));
    }
  }

  try {
    this.validateOptions(options);
  }
  catch (error) {
    return failure(error);
  }

  payload = this.checkOtherOptions(secretOrPrivateKey, options, tokenProfile, payload, failure);
  payload = this.checkOptions(tokenProfile.optionsToPayload, options, payload, failure);
  payload = this.checkOptions(tokenProfile.knownOptionalClaims, options, payload, failure);
 
  var messageInfo = { "header": header, "payload": payload, "options": options};
  return messageInfo;
};

/** Initialize options
 * @param {dictionary} options
 */
messageSigner.initOptions = function(options){
  if (typeof options === 'function') {
    callback = options;
    options = {};
  } else {
    options = options || {};
  }
  return options;
}

/**
 * Check for other options values and for duplicates
 * 
 * @param {string} secretOrPublicKey A string or buffer containing either the secret for HMAC algorithms, or the PEM encoded public key for RSA and ECDSA.
 * @param {dictionary} options Other inputs that are not part of the payload, for ex : 'algorithm'.
 * @param {Token} tokenProfile Contains the token properties, required, optional and verification claim.
 * @param {dictionary} payload Could be an object literal, buffer or string, containing claims. Please note that exp is only set if the payload is an object literal.
 * @returns {dictionary} payload
 * @throws Error if duplicate options values provided or does not match expected value.
 * @memberof MessageSigner
 */
messageSigner.checkOtherOptions = function(secretOrPrivateKey, options, tokenProfile, payload, failure){

  var timestamp = payload.iat || Math.floor(Date.now() / 1000);
  
    if (!options.noTimestamp) {
      payload.iat = timestamp;
    } else {
      delete payload.iat;
    }

  if (!secretOrPrivateKey &amp;&amp; options.algorithm !== 'none') {
    return failure(new Error('secretOrPrivateKey must have a value'));
  }

   // Check none algorithm status
   if (options.algorithm == 'none' &amp;&amp; tokenProfile.getNoneAlgorithm() == false){
    return failure(new Error('Cannot use none algorithm unless specified'));
  } 

  if (typeof payload.exp !== 'undefined' &amp;&amp; typeof options.expiresIn !== 'undefined') {
    return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
  }

  if (typeof payload.nbf !== 'undefined' &amp;&amp; typeof options.notBefore !== 'undefined') {
    return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
  }

  
  if (typeof options.notBefore !== 'undefined') {
    payload.nbf = timespan(options.notBefore);
    if (typeof payload.nbf === 'undefined') {
      return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
    }
  }

  if (typeof options.expiresIn !== 'undefined' &amp;&amp; typeof payload === 'object') {
    payload.exp = timespan(options.expiresIn, timestamp);
    if (typeof payload.exp === 'undefined') {
      return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
    }
  }

  return payload;
}

/** 
 * Check if the payload and options have a duplicate property 
 * @param {dictionary} tokenProfileKnownClaims
 * @param {dictionary} options
 * @param {dictionary} payload
 * @param {function} failure
 * */ 
messageSigner.checkOptions = function(tokenProfileKnownClaims, options, payload, failure){
  Object.keys(tokenProfileKnownClaims).forEach(function (key) {
    var claim = tokenProfileKnownClaims[key];
    if (typeof options[key] !== 'undefined') {
      if (typeof payload[claim] !== 'undefined') {
        return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
      }
      payload[claim] = options[key];
    }
  });
  return payload;
};

module.exports = messageSigner;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AccessToken.html">AccessToken</a></li><li><a href="BasicIdToken.html">BasicIdToken</a></li><li><a href="ExtendedIdToken.html">ExtendedIdToken</a></li><li><a href="FacebookIdToken.html">FacebookIdToken</a></li><li><a href="GoogleIdToken.html">GoogleIdToken</a></li><li><a href="ImplicitAccessToken.html">ImplicitAccessToken</a></li><li><a href="JWTDecoder.html">JWTDecoder</a></li><li><a href="JWTSigner.html">JWTSigner</a></li><li><a href="JWTVerifier.html">JWTVerifier</a></li><li><a href="KeyBundle.html">KeyBundle</a></li><li><a href="KeyJar.html">KeyJar</a></li><li><a href="MessageSigner.html">MessageSigner</a></li><li><a href="MessageVerifier.html">MessageVerifier</a></li><li><a href="RefreshToken.html">RefreshToken</a></li><li><a href="RiscToken.html">RiscToken</a></li><li><a href="ScopedAccessToken.html">ScopedAccessToken</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Wed Feb 07 2018 18:44:47 GMT-0800 (PST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
